<!doctype html><html lang=en-US><head><meta charset=utf-8><title>Running a Buildkit ARM Builder | Josh Kasuboski</title>
<meta name=description content="Josh Kasuboski's personal site"><meta name=author content="Josh Kasuboski"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.joshkasuboski.com/img/josh-scotland-full.jpg"><meta name=twitter:title content="Running a Buildkit ARM Builder"><meta name=twitter:description content="I was sick of my hour long ARM docker builds. A 15x speedup using existing infrastructure isn‚Äôt bad."><meta property="og:url" content="https://www.joshkasuboski.com/posts/buildkit-builder/"><meta property="og:site_name" content="Josh Kasuboski"><meta property="og:title" content="Running a Buildkit ARM Builder"><meta property="og:description" content="I was sick of my hour long ARM docker builds. A 15x speedup using existing infrastructure isn‚Äôt bad."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-08T15:34:19-05:00"><meta property="article:modified_time" content="2022-05-08T15:34:19-05:00"><meta property="og:image" content="https://www.joshkasuboski.com/img/josh-scotland-full.jpg"><link rel=me href=mailto:josh.kasuboski@gmail.com><link rel=me href=https://github.com/kasuboski><link data-proofer-ignore rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link data-proofer-ignore rel=microsub href=https://microsub.joshcorp.co/microsub><link rel=alternate type=application/rss+xml href=https://www.joshkasuboski.com/index.xml><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://unpkg.com/turretcss/dist/turretcss.min.css crossorigin=anonymous><style>@media only screen and (min-width:768px){:root{font-size:18px}}body{background-color:#faf9fa}pre{background-color:#d4f2e1}a{text-decoration-color:#5965f9}#site-header{box-shadow:0 4px 12px rgba(0,0,0,5%)}#intro{background-color:#e6e8fe}#social a{color:transparent;text-decoration:none}</style></head><body><div class=padding-bottom-s><header id=site-header><div class="container max-width-l flex-justify-center padding-vertical-xs"><h1 class=no-margin-bottom><a class="text-decoration-none flex align-items-center" href=https://www.joshkasuboski.com/><img alt="jk logo" class="icon-s margin-right-xs" src=https://www.joshkasuboski.com/images/jk-logo.svg><small>Josh Kasuboski</small></a></h1><nav class=nav-inline><ul><li><a href=/about/>About</a></li><li><a href=/now/>Now</a></li></ul></nav></div></header><main class="container max-width-l margin-top-l"><article class=h-entry><header><h1 class="display-title-xl no-margin-bottom post-title p-name">Running a Buildkit ARM Builder</h1><p class="post-date no-margin-top">Posted on
<time class=dt-published datetime=2022-05-08T15:34:19-05:00>8 May, 2022
</time>by <a href=https://www.joshkasuboski.com/ class="p-author h-card" rel=author>Josh Kasuboski</a> ¬∑ 6min read</p></header><section class="content e-content margin-top-l"><p>I was sick of my hour long ARM docker builds. A 15x speedup using existing infrastructure isn&rsquo;t bad.</p><h2 id=the-problem>The Problem</h2><p>I build my feedreader for ARM in Github Actions. The workflow builds a multi-arch docker image on push. The x86 build was pretty quick, but the ARM build was using qemu which made it take around an hour. QEMU certainly didn&rsquo;t help, but the Github Actions runners aren&rsquo;t exactly the biggest machines at 2 vcpu and 7GB ram.</p><p>My build was using the <a href=https://github.com/docker/setup-buildx-action>docker buildx</a> action. This makes the build use the newish buildkit backend for docker, but it&rsquo;s still running on the actions runner. I wanted to see if I could run my own buildkit backend. There was the option to connect it with a remote docker endpoint or a kubernetes cluster. Neither of which are really that appealing to me, although exposing the docker daemon over Tailscale could be fun.</p><h2 id=the-solution>The Solution</h2><p>Right as I was looking to run my own <code>buildkitd</code>, <code>buildx</code> had a PR merged that would enable a remote builder driver. This lets you run <code>buildkitd</code> somewhere and expose it over tcp. My <a href=https://www.joshkasuboski.com/posts/multi-region-k3s/>kubernetes cluster</a> has a free ARM node from Oracle that is pretty big (4 x 24GB). It&rsquo;s usually nowhere near fully utilized.</p><p>Running a builder on it seemed like a great way to use the excess resources. Combined with <code>tailscale</code> and the recommended mTLS auth I could have a rather secure build runner on my existing infrastructure.</p><h2 id=setting-it-up>Setting it up</h2><p>The <a href=https://github.com/moby/buildkit#expose-buildkit-as-a-tcp-service>buildkit</a> repo has instructions for running it over TCP. There is also an <a href=https://github.com/moby/buildkit/tree/master/examples/kubernetes#deployment--service>example</a> that shows how to run it in kubernetes with a deployment. I chose the deployment and service option vs a statefulset with consistent hashing because I was planning to use registry caching anyway and don&rsquo;t have immediate plans for many different builds to use this.</p><p>I decided to expose it with Tailscale using the same <a href=https://www.joshkasuboski.com/posts/tailscale-connect-kubernetes-pods/>process</a> I had previously used for my feedreader. This means connecting to it requires you be on my tailnet (authenticated with Tailscale).</p><p>In addition to requiring you be authenticated with Tailscale, the doc still recommends you use mTLS because the steps being built in the builder could potentially access the daemon as well. The example has a script to set up the certs for you, but I wanted to use the step cli from <a href=https://smallstep.com/>Smallstep</a>. It&rsquo;s still very simple, but I could control exactly what is set up.</p><h3 id=creating-certificates>Creating Certificates</h3><p>The first step to run <code>buildkitd</code> was to create the certificates it wants. I decided to make a Root CA for this along with an Intermediate CA and then server and client certificates. I didn&rsquo;t spend too long debating this and just followed a Smallstep guide&mldr;</p><p>Creating the CA</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>step certificate create --profile root-ca <span style=color:#e6db74>&#34;Buildkit Root CA&#34;</span> root_ca.crt root_ca.key
</span></span></code></pre></div><p>Creating the Intermediate CA</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>step certificate create <span style=color:#e6db74>&#34;Buildkit Intermediate CA 1&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    intermediate_ca.crt intermediate_ca.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --profile intermediate-ca --ca ./root_ca.crt --ca-key ./root_ca.key
</span></span></code></pre></div><p>Creating the server cert</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>step certificate create buildkitd --san buildkitd --san localhost --san 127.0.0.1 buildkitd.crt buildkitd.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --profile leaf --not-after<span style=color:#f92672>=</span>8760h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --ca ./intermediate_ca.crt --ca-key ./intermediate_ca.key --bundle --no-password --insecure
</span></span></code></pre></div><p>Creating the client cert</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>step certificate create client client.crt client.key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --profile leaf --not-after<span style=color:#f92672>=</span>8760h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --ca ./intermediate_ca.crt --ca-key ./intermediate_ca.key --bundle --no-password --insecure
</span></span></code></pre></div><p>You&rsquo;ll notice the server has a <code>buildkitd</code> san, which is how I&rsquo;ll access it over Tailscale. The <code>local</code> ones were for testing while port forwarding to the cluster.</p><h3 id=running-the-server>Running the Server</h3><p>You can find the example kubernetes yaml <a href=https://github.com/moby/buildkit/blob/master/examples/kubernetes/deployment%2Bservice.rootless.yaml>here</a>. It expects a kubernetes secret with <code>ca.pem</code> and <code>key.pem</code> keys. You can generate that from below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create secret generic buildkit-daemon-certs --from-file<span style=color:#f92672>=</span>key.pem<span style=color:#f92672>=</span>buildkitd.key --from-file<span style=color:#f92672>=</span>ca.pem<span style=color:#f92672>=</span>root_ca.crt --dry-run<span style=color:#f92672>=</span>client -oyaml
</span></span></code></pre></div><p>My actual deployment can be found in <a href=https://github.com/kasuboski/k8s-gitops/tree/main/builder/buildkit>kasuboski/k8s-gitops</a>. It includes the <a href=https://github.com/kasuboski/tailscale-proxy>tailscale-proxy</a> as well as a <code>nodeSelector</code> to make sure it schedules on the ARM node. It requests 1cpu and 512Mi with the limit set to 3.5cpu and 3Gi. It ends up having more cpu than Github Actions and isn&rsquo;t emulated. The memory is less, but hasn&rsquo;t been an issue.</p><p>Once the server is running, it will be available in tailscale at <code>buildkitd</code> since the proxy uses the deployment name.</p><h3 id=connecting-as-a-client>Connecting as a Client</h3><p>The client needs to have access over tailscale and a client cert. The easiest way is to use <code>buildctl</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>buildctl --addr <span style=color:#e6db74>&#39;tcp://buildkitd:1234&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --tlscacert root_ca.crt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --tlscert client.crt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --tlskey client.key  <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    build --frontend dockerfile.v0 --local context<span style=color:#f92672>=</span>. --local dockerfile<span style=color:#f92672>=</span>.
</span></span></code></pre></div><p>Building on multiple platforms with different builders requires <code>docker buildx</code>. The remote driver is on <code>master</code>, but isn&rsquo;t in a release yet. You can build buildx yourself to get access to that feature, but I only used it from Github Actions.</p><p>The <a href=https://github.com/docker/setup-buildx-action>setup buildx action</a> has the option to build buildx from a specific commit.</p><h3 id=running-in-github-actions>Running in Github Actions</h3><p>If you want to skip to the workflow it&rsquo;s at <a href=https://github.com/kasuboski/feedreader/blob/696debe2da1d26f1e4047806ff5e1f5ca5fbe347/.github/workflows/ci.yaml>kasuboski/feedreader</a>.</p><p>The workflow will need secrets for Tailscale and the certificates. I use <a href="https://doppler.com/join?invite=390F66AC">Doppler</a> <em>referral link</em> to manage the secrets. It synced super fast and has a nicer interface than doing it per repo in Github imo.</p><p>Tailscale has a Github Action that will install and set it up given an auth key. They support ephemeral auth keys so you won&rsquo;t have a bunch of leftover machines in their system. Once installed, your workflow will have access to your tailnet and can reach <code>buildkitd</code>. It&rsquo;s worth noting DNS magically works thanks to <a href=https://tailscale.com/kb/1081/magicdns/>Magic DNS</a>. Connecting to a kubernetes pod with a nice name and no other network setup is life changing.</p><p>I had problems using the remote buildx driver with a different builder type. I ended up just running another <code>buildkitd</code> on the actions runner. In the future, I&rsquo;d like to run an x86 builder on one of my nodes.</p><p>That&rsquo;s setup following inspiration from the buildx tests. This builder doesn&rsquo;t have mTLS setup, but I guess I&rsquo;m fine for now since it&rsquo;s an ephemeral runner on Github&rsquo;s infrastructure ü§∑‚Äç‚ôÇÔ∏è.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d --name buildkitd --privileged -p 1234:1234 moby/buildkit:buildx-stable-1 --addr tcp://0.0.0.0:1234
</span></span><span style=display:flex><span>docker buildx create --name gh-builder --driver remote --use tcp://0.0.0.0:1234
</span></span><span style=display:flex><span>docker buildx inspect --bootstrap
</span></span></code></pre></div><p>Adding my arm runner is done after as below. The certs have already been written to disk from the Github secrets.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker buildx create --append --name gh-builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --node arm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --driver remote <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --driver-opt key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$GITHUB_WORKSPACE<span style=color:#e6db74>/key.pem&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --driver-opt cert<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$GITHUB_WORKSPACE<span style=color:#e6db74>/client_cert.pem&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --driver-opt cacert<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$GITHUB_WORKSPACE<span style=color:#e6db74>/ca_cert.pem&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tcp://buildkitd:1234
</span></span><span style=display:flex><span>docker buildx ls
</span></span></code></pre></div><p>The <code>docker buildx ls</code> output should then show a <code>gh-builder</code> with two nodes, one supporting <code>amd64</code> and the other <code>arm</code>.<figure><a href=buildx-ls.png><img src=/posts/buildkit-builder/buildx-ls.png alt="Docker Buildx List"></a></figure></p><p>After setting up the builder, the workflow went from an hour to under four minutes.</p><h2 id=next-steps>Next Steps</h2><p>Building on my excess capacity has been great and I want to add an x86 node as well. I could have run my own Github Runners, but that seems much more intense. All of my repos are public as well, so I figure I might as well use the free actions minutes.</p><p>I do want to potentially make a service that will just give you a remote buildkit builder on demand. It&rsquo;s particularly helpful for ARM builds since those can be slow in emulation.</p><p>I also looked into the cross compilation options, but just getting a native builder seemed easier and more flexible. Your <code>Dockerfile</code> still has to not download a specific architecture explicitly, but otherwise most should be able to build multi-arch with this setup.</p></section><footer class=margin-top-m><a class="permalink u-url text-decoration-none" href=https://www.joshkasuboski.com/posts/buildkit-builder/>üîó</a></footer></article><nav class="margin-top-l flex justify-content-space-around"><div><a alt="Newer article" href=https://www.joshkasuboski.com/posts/local-tools-asdf/>&larr; Using asdf for Installing my Local Dev Environment</a></div><div class=show-s-up><a data-proofer-ignore alt="Top of page" href=#>Top</a></div><div><a alt="Older article" href=https://www.joshkasuboski.com/posts/tailscale-connect-kubernetes-pods/>Connect to Kubernetes Pods with Tailscale &rarr;</a></div></nav></main><footer class="container max-width-l margin-top-xl"><div class=margin-bottom-m><h4>Get more of my thoughts in an email newsletter!</h4><form action=https://buttondown.email/api/emails/embed-subscribe/kasuboski method=post target=popupwindow onsubmit='window.open("https://buttondown.email/kasuboski","popupwindow")' class=embeddable-buttondown-form><label for=bd-email>Your Email</label>
<input type=email name=email id=bd-email placeholder=me@email.com></input>
<input type=hidden value=1 name=embed></input>
<button class="button button-primary button-border" type=submit value=Subscribe>Subscribe</button><p class=font-size-s><a href=https://buttondown.email target=_blank>Powered by Buttondown.</a></p></form></div><div class="box-shadow-l padding-m"><div class="h-card flex align-content-center"><figure class=icon-xxl><img alt="profile photo" class=u-photo src=https://www.joshkasuboski.com/img/josh-scotland.jpg></figure><div class=margin-left-m><h3 class=display-title><a class="u-url p-name text-decoration-none" href=https://www.joshkasuboski.com/>Josh Kasuboski</a></h3><p>Living in Austin <img class=icon-xs style=vertical-align:middle alt=texas src=https://www.joshkasuboski.com/img/tx-fill.png> from <img class=icon-xs style=vertical-align:middle alt=wisconsin src=https://www.joshkasuboski.com/img/wi-fill.png></p><p id=social><a rel=me class="u-url margin-right-xs" href=https://github.com/kasuboski><img class=icon-xs src=https://www.joshkasuboski.com/icons/github.svg alt=github>
</a><a class=margin-right-xs href=https://linkedin.com/in/joshkasuboski/><img class=icon-xs src=https://www.joshkasuboski.com/icons/linkedin.svg alt=linkedin>
</a><a href=mailto:josh.kasuboski@gmail.com class="u-email margin-right-xxs" rel=me><img class=icon-xs src=https://www.joshkasuboski.com/icons/envelope.svg alt=email>
</a><a href=https://www.joshkasuboski.com/payments/><img class=icon-xs src=https://www.joshkasuboski.com/icons/beer-money-icon.svg alt=beermoney></a></p></div></div></div></footer></div><script async src=https://rum.cronitor.io/script.js></script><script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"b2a9cb0f440d559169438f89c882dddb"})</script></body></html>